<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Coroutines &mdash; kaa.base v0.99.2 documentation</title>
    <link rel="stylesheet" href="../_static/kaa.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.99.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="kaa.base v0.99.2 documentation" href="../index.html" />
    <link rel="next" title="Thread Support" href="threads.html" />
    <link rel="prev" title="InProgress Objects" href="inprogress.html" />
    <!-- link rel="stylesheet" href="../_static/kaa.css" type="text/css" /-->

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="threads.html" title="Thread Support"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inprogress.html" title="InProgress Objects"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">kaa.base v0.99.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="coroutines">
<span id="id1"></span><h1>Coroutines<a class="headerlink" href="#coroutines" title="Permalink to this headline">¶</a></h1>
<p>Coroutines are used to break up large and computationally expensive
tasks into smaller tasks, where control is relinquished to the main
loop after each smaller task. Coroutines are also very useful in
constructing state machines. In the event where blocking is
unavoidable, and the duration of the block is unknown (for example,
connecting to a remote host, or scaling a very large image), threads
can be used. These two different approaches are unified with a very
similar API.</p>
<p>A function or method is designated a coroutine by using the &#64;kaa.coroutine
decorator.  A coroutine allows a larger tasks to be broken down into smaller
ones by yielding control back to the &#8220;scheduler&#8221; (the <a class="reference external" href="../core/mainloop.html#notifier"><em>notifier</em></a>), implementing a kind of cooperative multitasking.  More usefully,
coroutines can yield at points where they may otherwise block on resources
(e.g. disk or network), and when the resource becomes available, the coroutine
resumes where it left off.  With coroutines and <a class="reference external" href="inprogress.html#inprogress"><em>InProgress</em></a>
objects, it is possible to construct non-trivial state machines, whose state is
modified by asynchronous events, using a single coroutine.  Without coroutines,
this is typically implemented as a series of smaller callback functions.  (For
more information on coroutines, see <a class="reference external" href="http://en.wikipedia.org/wiki/Coroutine">Wikipedia&#8217;s treatment of the subject</a>.)</p>
<p>Any function decorated with coroutine will return an InProgress object, and the
caller can connect a callback to the InProgress object in order to be notified
of its return value or any exception.</p>
<p>When a coroutine yields kaa.NotFinished, control is returned to the
main loop, and the coroutine will resume after the yield statement
at the next main loop iteration, or, if an interval is provided with the
decorator, after this time interval.  Following the cooperative multitasking
analogy, yielding kaa.NotFinished can be thought of as the coroutine releasing
a &#8220;time slice&#8221; so that other tasks may run.</p>
<p>When a coroutine yields any value other than kaa.NotFinished (including None),
the coroutine is considered finished and the InProgress returned to the caller
will be <a class="reference external" href="../core/signals.html#emitting"><em>emitted</em></a> (i.e. it is finished). As with return, if no value is
explicitly yielded and the coroutine terminates, the InProgress is finished
with None.</p>
<p>There is an important exception to the above rule: if the coroutine yields an
<a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> object, the coroutine will be resumed when the
InProgress object is finished.  This allows a coroutine to be &#8220;chained&#8221; with
other InProgress tasks, including other coroutines.</p>
<p>To recap, if a coroutine yields:</p>
<blockquote>
<ul class="simple">
<li><cite>kaa.NotFinished</cite>: control is returned to the main loop so that other tasks
can run (such as other timers, I/O handlers, etc.) and resumed on the next
main loop iteration.</li>
<li>an <a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> object: control is returned to the main loop and
the coroutine is resumed with the yielded InProgress is finished.  Inside
the coroutine, the yield call &#8220;returns&#8221; the value that InProgress was finished
with.</li>
<li>any other value: the coroutine terminates, and the InProgress the coroutine
returned to the caller is finished with that value (which includes None, if
no value was explicitly yielded and the coroutine reaches the end naturally).</li>
</ul>
</blockquote>
<p>Here is a simple example that breaks up a loop into smaller tasks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">kaa</span>

<span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">do_something</span><span class="p">():</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
      <span class="n">do_something_expensive</span><span class="p">()</span>
      <span class="k">yield</span> <span class="n">kaa</span><span class="o">.</span><span class="n">NotFinished</span>
   <span class="k">yield</span> <span class="mi">42</span>

<span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
   <span class="k">print</span> <span class="s">&quot;do_something() finished with result:&quot;</span><span class="p">,</span> <span class="n">result</span>

<span class="n">do_something</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">handle_result</span><span class="p">)</span>
<span class="n">kaa</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>A coroutine can yield other coroutines (or rather, the InProgress
object the other coroutine returns):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">do_something_else</span><span class="p">():</span>
   <span class="k">try</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">do_something</span><span class="p">()</span>
   <span class="k">except</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&quot;do_something failed&quot;</span>
      <span class="k">yield</span>

   <span class="k">yield</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="bp">False</span>
</pre></div>
</div>
<p>(Note that the above syntax, in which the yield statement returns a value,
was introduced in Python 2.5.  kaa.base requires Python 2.5 or later.)</p>
<p>Classes in kaa make heavy use of coroutines and (to a lesser extent) threads
when methods would otherwise block on some resource.  Both coroutines and
<a class="reference external" href="threads.html#threaded"><em>&#64;threaded</em></a>-decorated methods return InProgress objects and behave identically.
These can be therefore yielded from a coroutine in the same way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches / from the given host on port 80.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="n">kaa</span><span class="o">.</span><span class="n">Socket</span><span class="p">()</span>
    <span class="c"># Socket.connect() is implemented as a thread</span>
    <span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="c"># Socket.read() and write() are implemented as single-thread async I/O.</span>
    <span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;GET / HTTP/1.1</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="p">(</span><span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p>In the above example, the difference between threaded functions
(<a title="kaa.Socket.connect" class="reference external" href="../core/socket.html#kaa.Socket.connect"><tt class="xref docutils literal"><span class="pre">kaa.Socket.connect()</span></tt></a>) and coroutines (<a title="kaa.IOChannel.write" class="reference external" href="../core/io.html#kaa.IOChannel.write"><tt class="xref docutils literal"><span class="pre">write()</span></tt></a> and
<a title="kaa.IOChannel.read" class="reference external" href="../core/io.html#kaa.IOChannel.read"><tt class="xref docutils literal"><span class="pre">read()</span></tt></a>) is transparent.  Both return InProgress objects. (As
an aside, we didn&#8217;t really need to yield socket.write() because writes are
queued and written to the socket when it becomes writable.  However, yielding a
write means that when the coroutine resumes, the data has been
written.)</p>
<p>To more clearly see the benefit of implementing the above example as a coroutine,
consider the following code, which is rewritten using the more traditional approach
of connecting callbacks at the various stages of the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="n">kaa</span><span class="o">.</span><span class="n">Socket</span><span class="p">()</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_connect</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_connect</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;GET / HTTP/1.1</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_write</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_write</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_read</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_read</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">data</span>
</pre></div>
</div>
<p>In practice then, coroutines can be seen as an alternative approach to the
classic signal/callback pattern, allowing you to achieve the same logic but
with a much more intuitive and readable code.  This means that if you design
your application to use signals and callbacks, it might not be clear where
coroutines would be useful.</p>
<p>However, if you make use of the asynchronous plumbing that kaa offers early on
in your design &#8211; and that includes healthy use of <a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a>
objects, either explicitly or implicitly through the use of the &#64;coroutine
and <a class="reference external" href="threads.html#threaded"><em>&#64;threaded</em></a> decorators &#8211; you should find that you&#8217;re able
to produce some surprisingly elegant, non-trivial code.</p>
<div class="section" id="decorator">
<h2>Decorator<a class="headerlink" href="#decorator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="kaa.coroutine">
<tt class="descclassname">kaa.</tt><tt class="descname">coroutine</tt><big>(</big><em>interval=0</em>, <em>policy=None</em>, <em>progress=False</em>, <em>group=None</em><big>)</big><a class="headerlink" href="#kaa.coroutine" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorated functions (which must be generators) may yield control
back to the mainloop and be subsequently resumed at a later time.</p>
<p>Functions which yield <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> will be resumed on the
next mainloop iteration; yielding an <a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> object
will cause the coroutine to be resumed when the InProgress is finished.
However, yielding a <em>finished</em> InProgress object will cause the coroutine
to be resumed immediately.</p>
<p>The coroutine is considered finished when the underlying generator yields
a value other than <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or an InProgress object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>interval</em> &#8211; Number of seconds to delay before resuming entry into
the coroutine.  Set to 0 (default) to resume as soon as
possible (but not sooner than the next mainloop iteration).</li>
<li><em>policy</em> &#8211; None, or one of <tt class="docutils literal"><span class="pre">POLICY_SYNCHRONIZED</span></tt>, <tt class="docutils literal"><span class="pre">POLICY_SINGLETON</span></tt>, or
<tt class="docutils literal"><span class="pre">POLICY_PASS_LAST</span></tt> (described below).</li>
<li><em>progress</em> &#8211; if True, a Progress object is passed as the first argument to
the decorated function, allowing the coroutine to report progress
to the caller.  (The progress parameter corresponds to the
<tt class="docutils literal"><span class="pre">progress</span></tt> attribute of the InProgress object returned to
the caller.)</li>
<li><em>group</em> &#8211; Name of the group this coroutine shares its policy with.  For
example, multiple coroutines with POLICY_SYNCHRONIZED and the
same group name will all be synchronized against each other.
Currently only methods within the same class may belong to
the same group.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an <a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> object representing the coroutine.</p>
</td>
</tr>
</tbody>
</table>
<p>Possible policies are:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_SYNCHRONIZED</span></tt>: reentry into the coroutine is not permitted,
and multiple calls are queued so that they execute sequentially.</li>
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_SINGLETON</span></tt>: only one active instance of the coroutine is allowed
to exist.  If the coroutine is invoked while another is running,
the CoroutineInProgress object returned by the first invocation
until it finishes.</li>
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_PASS_LAST</span></tt>: passes the CoroutineInProgress of the most recently
called, unfinished invocation of this coroutine as the &#8216;last&#8217;
kwarg.  If no such CoroutineInProgress exists, the last kwarg will
be None.  This is useful to chain multiple invocations of the
coroutine together, but unlike <tt class="docutils literal"><span class="pre">POLICY_SYNCHRONIZED</span></tt>, the decorated
function is entered each invocation.</li>
</ul>
</blockquote>
<p>A function decorated with this decorator will always return an
<a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> object. It may already be finished (which happens if
the coroutine&#8217;s first yielded value is one other than <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or  
an InProgress object).</p>
<p>If it is not finished, the coroutine&#8217;s life can be controlled via the
<a title="kaa.InProgress" class="reference external" href="inprogress.html#kaa.InProgress"><tt class="xref docutils literal"><span class="pre">InProgress</span></tt></a> it returns.  It can be aborted with
<a title="kaa.InProgress.abort" class="reference external" href="inprogress.html#kaa.InProgress.abort"><tt class="xref docutils literal"><span class="pre">abort()</span></tt></a>, in which case a GeneratorExit will be raised
inside the coroutine, or its interval may be adjusted via the
<tt class="xref docutils literal"><span class="pre">interval</span></tt> property.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Coroutines</a><ul>
<li><a class="reference external" href="#decorator">Decorator</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="inprogress.html"
                                  title="previous chapter">InProgress Objects</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="threads.html"
                                  title="next chapter">Thread Support</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/async/coroutines.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="threads.html" title="Thread Support"
             >next</a> |</li>
        <li class="right" >
          <a href="inprogress.html" title="InProgress Objects"
             >previous</a> |</li>
        <li><a href="../index.html">kaa.base v0.99.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2005-2012, Dirk Meyer, Jason Tackaberry.
      Last updated on Jan 14, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>