

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Coroutines &mdash; kaa.base 0.99.2dev-406-2796ba76 documentation</title>
    
    <link rel="stylesheet" href="../_static/kaa.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.99.2dev-406-2796ba76',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="kaa.base 0.99.2dev-406-2796ba76 documentation" href="../index.html" />
    <link rel="next" title="Thread Support" href="threads.html" />
    <link rel="prev" title="InProgress Objects" href="inprogress.html" />
    <!-- link rel="stylesheet" href="../_static/kaa.css" type="text/css" /-->

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="threads.html" title="Thread Support"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inprogress.html" title="InProgress Objects"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">kaa.base 0.99.2dev-406-2796ba76 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-kaa.coroutine"></span><div class="section" id="coroutines">
<span id="id1"></span><h1>Coroutines<a class="headerlink" href="#coroutines" title="Permalink to this headline">¶</a></h1>
<p>Coroutines are special functions that have multiple entry points that allow
suspending and resuming execution at specified locations.  They allow you to:</p>
<blockquote>
<div><ul class="simple">
<li>write sequentially flowing code involving potentially blocking tasks (e.g.
socket IO) that is actually completely non-blocking</li>
<li>&#8220;time slice&#8221; large, computationally expensive tasks to avoid blocking</li>
<li>help solve complex problems involving state <a class="reference external" href="http://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines/">without using explicit state machines</a></li>
</ul>
</div></blockquote>
<p>In the event where blocking is unavoidable, and the duration of the block is
unknown (for example, connecting to a remote host, or scaling a very large
image), threads can be used.  These two different approaches are unified with a
very similar API.</p>
<p>A function or method is designated a coroutine by using the <tt class="docutils literal"><span class="pre">&#64;kaa.coroutine</span></tt>
decorator.  A coroutine allows a larger tasks to be broken down into smaller
ones by yielding control back to the &#8220;scheduler&#8221; (the <a class="reference internal" href="../core/mainloop.html#notifier"><em>notifier</em></a>), implementing a kind of cooperative multitasking.  More usefully,
coroutines can yield at points where they may otherwise block on resources
(e.g. disk or network), and when the resource becomes available, the coroutine
resumes where it left off.  Without coroutines, this is typically implemented
as a series of smaller callback functions.  (For more information on
coroutines, see <a class="reference external" href="http://en.wikipedia.org/wiki/Coroutine">Wikipedia&#8217;s treatment of the subject</a>.)</p>
<p>Coroutines return an InProgress object, and the caller can connect a callback
to the InProgress object in order to be notified of its return value or any
exception, or it can yield the InProgress object from other coroutines.</p>
<p>When a coroutine yields <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt>, control is returned to the
main loop, and the coroutine will resume after the yield statement
at the next main loop iteration, or, if an interval is provided with the
decorator, after this time interval.  Following the cooperative multitasking
analogy, yielding <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> can be thought of as the coroutine releasing
a &#8220;time slice&#8221; so that other tasks may run.</p>
<p>When a coroutine yields any value other than <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> (including None),
the coroutine is considered finished and the InProgress returned to the caller
will be <a class="reference internal" href="../core/signals.html#emitting"><em>emitted</em></a> (i.e. it is finished). As with return, if no
value is explicitly yielded and the coroutine terminates, the InProgress is
finished with None.</p>
<p>There is an important exception to the above rule: if the coroutine yields an
<a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> object, the coroutine will be resumed when the
InProgress object is finished.  This allows a coroutine to be &#8220;chained&#8221; with
other InProgress tasks, including other coroutines.</p>
<p>To recap, if a coroutine yields:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt>: control is returned to the main loop so that other tasks
can run (such as other timers, I/O handlers, etc.) and resumed on the next
main loop iteration.</li>
<li>an <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> object: control is returned to the main loop and
the coroutine is resumed when the yielded InProgress is finished.  Inside
the coroutine, the yield call &#8220;returns&#8221; the value that InProgress was finished
with.</li>
<li>any other value: the coroutine terminates, and the InProgress the coroutine
returned to the caller is finished with that value (which includes None, if
no value was explicitly yielded and the coroutine reaches the end naturally).</li>
</ul>
</div></blockquote>
<p>Here is a simple example that breaks up a loop into smaller tasks:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">kaa</span>

<span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">do_something</span><span class="p">():</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
      <span class="n">do_something_expensive</span><span class="p">()</span>
      <span class="k">yield</span> <span class="n">kaa</span><span class="o">.</span><span class="n">NotFinished</span>
   <span class="k">yield</span> <span class="mi">42</span>

<span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
   <span class="k">print</span> <span class="s">&quot;do_something() finished with result:&quot;</span><span class="p">,</span> <span class="n">result</span>

<span class="n">do_something</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">handle_result</span><span class="p">)</span>
<span class="n">kaa</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>A coroutine can yield other coroutines (or rather, the InProgress
object the other coroutine returns):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">do_something_else</span><span class="p">():</span>
   <span class="k">try</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">do_something</span><span class="p">()</span>
   <span class="k">except</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&quot;do_something failed&quot;</span>
      <span class="k">yield</span>

   <span class="k">yield</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="bp">False</span>
</pre></div>
</div>
<p>(Note that the above syntax, in which the yield statement returns a value,
was introduced in Python 2.5.  kaa.base requires Python 2.5 or later.)</p>
<p>Classes in kaa make heavy use of coroutines and (to a lesser extent) threads
when methods would otherwise block on some resource.  Both coroutines and
<a class="reference internal" href="threads.html#threaded"><em>&#64;threaded</em></a>-decorated methods return InProgress objects and behave identically.
These can be therefore yielded from a coroutine in the same way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetches / from the given host on port 80.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="n">kaa</span><span class="o">.</span><span class="n">Socket</span><span class="p">()</span>
    <span class="c"># Socket.connect() is implemented as a thread</span>
    <span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="c"># Socket.read() and write() are implemented as single-thread async I/O.</span>
    <span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;GET / HTTP/1.1</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="p">(</span><span class="k">yield</span> <span class="n">socket</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p>In the above example, the difference between threaded functions
(<a class="reference internal" href="../core/socket.html#kaa.Socket.connect" title="kaa.Socket.connect"><tt class="xref py py-meth docutils literal"><span class="pre">kaa.Socket.connect()</span></tt></a>) and coroutines (<a class="reference internal" href="../core/io.html#kaa.IOChannel.write" title="kaa.IOChannel.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a> and
<a class="reference internal" href="../core/io.html#kaa.IOChannel.read" title="kaa.IOChannel.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a>) is transparent.  Both return InProgress objects. (As
an aside, we didn&#8217;t really need to yield socket.write() because writes are
queued and written to the socket when it becomes writable.  However, yielding a
write means that when the coroutine resumes, the data has been fully sent to the
socket.)</p>
<p>To more clearly see the benefit of implementing the above example as a coroutine,
consider the following code, which is rewritten using the more traditional approach
of connecting callbacks at the various stages of the task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fetch_page</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="n">socket</span> <span class="o">=</span> <span class="n">kaa</span><span class="o">.</span><span class="n">Socket</span><span class="p">()</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_connect</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_connect</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;GET / HTTP/1.1</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_write</span><span class="p">,</span> <span class="n">socket</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_write</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">socket</span><span class="p">):</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">finished_read</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">finished_read</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">data</span>
</pre></div>
</div>
<p>In practice then, coroutines can be seen as an alternative approach to the
classic signal/callback pattern, allowing you to achieve the same logic but
with a much more intuitive and readable code.  This means that if you design
your application to use signals and callbacks, it might not be clear where
coroutines would be useful.</p>
<p>However, if you make use of the asynchronous plumbing that kaa offers early on
in your design &#8211; and that includes healthy use of <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a>
objects, either explicitly or implicitly through the use of the &#64;coroutine
and <a class="reference internal" href="threads.html#threaded"><em>&#64;threaded</em></a> decorators &#8211; you should find that you&#8217;re able
to produce some surprisingly elegant, non-trivial code.</p>
<div class="section" id="decorator">
<h2>Decorator<a class="headerlink" href="#decorator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="kaa.coroutine">
<tt class="descclassname">kaa.</tt><tt class="descname">coroutine</tt><big>(</big><em>interval=0</em>, <em>policy=None</em>, <em>progress=False</em>, <em>group=None</em><big>)</big><a class="headerlink" href="#kaa.coroutine" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorated functions (which must be generators) may yield control
back to the mainloop and be subsequently resumed at a later time.</p>
<p>Functions which yield <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> will be resumed on the
next mainloop iteration; yielding an <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> object
will cause the coroutine to be resumed when the InProgress is finished.
However, yielding a <em>finished</em> InProgress object will cause the coroutine
to be resumed immediately.</p>
<p>The coroutine is considered finished when the underlying generator yields
a value other than <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or an InProgress object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>interval</strong> &#8211; Number of seconds to delay before resuming entry into
the coroutine.  Set to 0 (default) to resume as soon as
possible (but not sooner than the next mainloop iteration).</li>
<li><strong>policy</strong> &#8211; None, or one of <tt class="docutils literal"><span class="pre">POLICY_SYNCHRONIZED</span></tt>, <tt class="docutils literal"><span class="pre">POLICY_SINGLETON</span></tt>, or
<tt class="docutils literal"><span class="pre">POLICY_PASS_LAST</span></tt> (described below).</li>
<li><strong>progress</strong> &#8211; if True, an <tt class="xref py py-class docutils literal"><span class="pre">InProgressStatus</span></tt> object is
passed as the first argument to the decorated function,
allowing the coroutine to report progress to the caller.
(The progress parameter corresponds to the <tt class="docutils literal"><span class="pre">progress</span></tt>
attribute of the InProgress object returned to the
caller.)</li>
<li><strong>group</strong> &#8211; Name of the group this coroutine shares its policy with.  For
example, multiple coroutines with POLICY_SYNCHRONIZED and the
same group name will all be synchronized against each other.
Currently only methods within the same class may belong to
the same group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <a class="reference internal" href="#kaa.CoroutineInProgress" title="kaa.CoroutineInProgress"><tt class="xref py py-class docutils literal"><span class="pre">CoroutineInProgress</span></tt></a> object representing the coroutine</p>
</td>
</tr>
</tbody>
</table>
<p>Possible policies are:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_SYNCHRONIZED</span></tt>: reentry into the coroutine is not permitted,
and multiple calls are queued so that they execute sequentially.</li>
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_SINGLETON</span></tt>: only one active instance of the coroutine is allowed
to exist.  If the coroutine is invoked while another is running,
the <a class="reference internal" href="#kaa.CoroutineInProgress" title="kaa.CoroutineInProgress"><tt class="xref py py-class docutils literal"><span class="pre">CoroutineInProgress</span></tt></a> object returned by the first invocation
until it finishes.</li>
<li><tt class="docutils literal"><span class="pre">kaa.POLICY_PASS_LAST</span></tt>: passes the <a class="reference internal" href="#kaa.CoroutineInProgress" title="kaa.CoroutineInProgress"><tt class="xref py py-class docutils literal"><span class="pre">CoroutineInProgress</span></tt></a>
of the most recently called, unfinished invocation of this coroutine
as the &#8216;last&#8217; kwarg.  If no such CoroutineInProgress exists, the last
kwarg will be None.  This is useful to chain multiple invocations of
the coroutine together, but unlike <tt class="docutils literal"><span class="pre">POLICY_SYNCHRONIZED</span></tt>, the
decorated function is entered each invocation.</li>
</ul>
</div></blockquote>
<p>A function decorated with this decorator will always return a
<a class="reference internal" href="#kaa.CoroutineInProgress" title="kaa.CoroutineInProgress"><tt class="xref py py-class docutils literal"><span class="pre">CoroutineInProgress</span></tt></a> object. It may already be finished (which
happens if the coroutine&#8217;s first yielded value is one other than
<tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or an <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> object).</p>
<p>If it is not finished, the coroutine&#8217;s life can be controlled via the
<a class="reference internal" href="#kaa.CoroutineInProgress" title="kaa.CoroutineInProgress"><tt class="xref py py-class docutils literal"><span class="pre">CoroutineInProgress</span></tt></a> it returns.  It can be aborted with
<a class="reference internal" href="inprogress.html#kaa.InProgress.abort" title="kaa.InProgress.abort"><tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt></a>, in which case an <cite>~kaa.InProgressAborted</cite>
will be raised inside the coroutine, or its interval may be adjusted via
the <a class="reference internal" href="#kaa.CoroutineInProgress.interval" title="kaa.CoroutineInProgress.interval"><tt class="xref py py-attr docutils literal"><span class="pre">interval</span></tt></a> property.</p>
</dd></dl>

<p><dl class="class">
<dt id="kaa.CoroutineInProgress">
<em class="property">class </em><tt class="descclassname">kaa.</tt><tt class="descname">CoroutineInProgress</tt><big>(</big><em>function</em>, <em>function_info</em>, <em>interval</em>, <em>progress=None</em><big>)</big><a class="headerlink" href="#kaa.CoroutineInProgress" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> object returned by the <tt class="xref py py-func docutils literal"><span class="pre">coroutine()</span></tt> decorator.</p>
<p>The caller of <a class="reference internal" href="#kaa.coroutine" title="kaa.coroutine"><tt class="xref py py-func docutils literal"><span class="pre">kaa.coroutine()</span></tt></a> can interact with the coroutine via the returned
<tt class="docutils literal"><span class="pre">CoroutineInProgress</span></tt> object, or yield it from other coroutines.</p>
<p>Notably, coroutines can be aborted by invoking <tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt> on this object.</p>
<p><h4>Synopsis</h4><div class="kaa synopsis">
<div class="heading">Class Hierarchy</div><p class="hierarchy"><a class="reference internal" href="../core/signals.html#kaa.Signal" title="kaa.Signal"><tt class="xref py py-class docutils literal"><span class="pre">kaa.Signal</span></tt></a><br /><tt class="xref py py-class docutils literal"><span class="pre">kaa.Object</span></tt><br />&#9492;&#9472; <a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">kaa.InProgress</span></tt></a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#9492;&#9472; <tt class="xref docutils literal current">kaa.CoroutineInProgress</tt><br /></p>
<div class="heading">Methods</div>
<table>
<tr class="row-odd"><th><a class="reference internal" href="#kaa.CoroutineInProgress.abort" title="kaa.CoroutineInProgress.abort"><tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt></a></th><td class="desc">Aborts the coroutine.</td></tr>
</table>
<div class="heading">Properties</div>
<table>
<tr class="row-even"><th><a class="reference internal" href="#kaa.CoroutineInProgress.active" title="kaa.CoroutineInProgress.active"><tt class="xref py py-attr docutils literal"><span class="pre">active</span></tt></a></th><td>read-only</td><td class="desc">True if the coroutine is still waiting to be processed, or False if it&#8217;s
finished.</td></tr>
<tr class="row-odd"><th><a class="reference internal" href="#kaa.CoroutineInProgress.interval" title="kaa.CoroutineInProgress.interval"><tt class="xref py py-attr docutils literal"><span class="pre">interval</span></tt></a></th><td>read/write</td><td class="desc">The interval between the coroutine yielding a <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or
<a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> and reentry.</td></tr>
</table>
<div class="heading">Signals</div>
<table>
<tr class="row-even"><th><a class="reference internal" href="#kaa.CoroutineInProgress.signals.abort" title="kaa.CoroutineInProgress.signals.abort"><tt class="xref py py-attr docutils literal"><span class="pre">abort</span></tt></a></th><td class="desc">Emitted when abort() is called.</td></tr>
</table>

</div>
<h4>Methods</h4><dl class="method">
<dt id="kaa.CoroutineInProgress.abort">
<tt class="descname">abort</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#kaa.CoroutineInProgress.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Aborts the coroutine.</p>
<p>See <a class="reference internal" href="inprogress.html#kaa.InProgress.abort" title="kaa.InProgress.abort"><tt class="xref py py-meth docutils literal"><span class="pre">kaa.InProgress.abort()</span></tt></a> for argument details.</p>
<p>This will raise the supplied exception (<a class="reference internal" href="inprogress.html#kaa.InProgressAborted" title="kaa.InProgressAborted"><tt class="xref py py-class docutils literal"><span class="pre">InProgressAborted</span></tt></a>
if not given) inside the coroutine.  If the coroutine doesn&#8217;t catch the
exception, then it will be raised back to the caller of <tt class="xref py py-meth docutils literal"><span class="pre">abort()</span></tt>.</p>
<p>If the coroutine being aborted is currently waiting on some other yielded
<a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> which is <a class="reference internal" href="inprogress.html#kaa.InProgress.abortable" title="kaa.InProgress.abortable"><tt class="xref py py-attr docutils literal"><span class="pre">abortable</span></tt></a>
(which includes other coroutines as well as <a class="reference internal" href="threads.html#kaa.threaded" title="kaa.threaded"><tt class="xref py py-func docutils literal"><span class="pre">threaded()</span></tt></a>
functions, both of which are abortable by default), then it will also
be aborted if and only if nothing else is waiting for it.</p>
<p>For example, a <tt class="docutils literal"><span class="pre">POLICY_SINGLETON</span></tt> coroutine <tt class="docutils literal"><span class="pre">z()</span></tt> that is yielded
from both coroutine <tt class="docutils literal"><span class="pre">a()</span></tt> and <tt class="docutils literal"><span class="pre">b()</span></tt> would not be aborted if either
<tt class="docutils literal"><span class="pre">a()</span></tt> or <tt class="docutils literal"><span class="pre">b()</span></tt> were aborted.  If you want <tt class="docutils literal"><span class="pre">z()</span></tt> to be aborted, then
<tt class="docutils literal"><span class="pre">a()</span></tt> and/or <tt class="docutils literal"><span class="pre">b()</span></tt> would need to catch <a class="reference internal" href="inprogress.html#kaa.InProgressAborted" title="kaa.InProgressAborted"><tt class="xref py py-class docutils literal"><span class="pre">InProgressAborted</span></tt></a>
when yielding <tt class="docutils literal"><span class="pre">z()</span></tt> and explicitly abort it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">kaa</span><span class="o">.</span><span class="n">POLICY_SINGLETON</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">z</span><span class="p">():</span>
    <span class="c"># do stuff ...</span>
    <span class="k">yield</span> <span class="n">whatever</span><span class="p">()</span>

<span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">z</span><span class="p">()</span>

<span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">z</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">kaa</span><span class="o">.</span><span class="n">InProgressAborted</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">e</span><span class="o">.</span><span class="n">inprogress</span><span class="o">.</span><span class="n">abort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, if <tt class="docutils literal"><span class="pre">abort()</span></tt> was called on <tt class="docutils literal"><span class="pre">b()</span></tt>, its exception handler
would abort <tt class="docutils literal"><span class="pre">z()</span></tt>, which could cause <a class="reference internal" href="inprogress.html#kaa.InProgressAborted" title="kaa.InProgressAborted"><tt class="xref py py-class docutils literal"><span class="pre">InProgressAborted</span></tt></a>
to be raised inside <tt class="docutils literal"><span class="pre">a()</span></tt>.  If <tt class="docutils literal"><span class="pre">b()</span></tt> didn&#8217;t exist in the above
example, <tt class="docutils literal"><span class="pre">z()</span></tt> would automatically be aborted.  You could prevent
this by using <tt class="xref py py-meth docutils literal"><span class="pre">noabort()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@kaa.coroutine</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">z</span><span class="p">()</span><span class="o">.</span><span class="n">noabort</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">kaa</span><span class="o">.</span><span class="n">InProgressAborted</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;b() is aborted, but z() lives on&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<h4>Properties</h4><dl class="attribute">
<dt id="kaa.CoroutineInProgress.active">
<tt class="descname">active</tt><a class="headerlink" href="#kaa.CoroutineInProgress.active" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the coroutine is still waiting to be processed, or False if it&#8217;s
finished.</p>
</dd></dl>

<dl class="attribute">
<dt id="kaa.CoroutineInProgress.interval">
<tt class="descname">interval</tt><a class="headerlink" href="#kaa.CoroutineInProgress.interval" title="Permalink to this definition">¶</a></dt>
<dd><p>The interval between the coroutine yielding a <tt class="docutils literal"><span class="pre">kaa.NotFinished</span></tt> or
<a class="reference internal" href="inprogress.html#kaa.InProgress" title="kaa.InProgress"><tt class="xref py py-class docutils literal"><span class="pre">InProgress</span></tt></a> and reentry.</p>
</dd></dl>

<h4>Signals</h4><dl class="attribute">
<dt id="kaa.CoroutineInProgress.signals.abort">
<tt class="descname">abort</tt><a class="headerlink" href="#kaa.CoroutineInProgress.signals.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Emitted when abort() is called.</p>
<dl class="describe">
<dt>
<tt class="descname">def callback(exc)</tt></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Param exc:</th><td class="field-body">an exception object the InProgress was aborted with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Type exc:</th><td class="field-body"><a class="reference internal" href="inprogress.html#kaa.InProgressAborted" title="kaa.InProgressAborted"><tt class="xref py py-class docutils literal"><span class="pre">InProgressAborted</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>If the task cannot be aborted, the callback can return False, which
will cause an exception to be raised by abort().</p>
</dd></dl>

</p>
</dd></dl>

</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Coroutines</a><ul>
<li><a class="reference internal" href="#decorator">Decorator</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="inprogress.html"
                        title="previous chapter">InProgress Objects</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="threads.html"
                        title="next chapter">Thread Support</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/async/coroutines.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="threads.html" title="Thread Support"
             >next</a> |</li>
        <li class="right" >
          <a href="inprogress.html" title="InProgress Objects"
             >previous</a> |</li>
        <li><a href="../index.html">kaa.base 0.99.2dev-406-2796ba76 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2005-2012, Dirk Meyer, Jason Tackaberry.
      Last updated on May 30, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>